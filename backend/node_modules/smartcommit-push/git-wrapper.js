const { execSync } = require("child_process");
const axios = require("axios");



function run(cmd) {
  try {
    return execSync(cmd, { stdio: "pipe", cwd: process.cwd() })
      .toString()
      .trim();
  } catch (err) {
    console.error(err.stdout?.toString() || err.message);
    throw new Error("Git command failed");
  }
}

const IGNORE_PATHS = [
  "node_modules/",
  "dist/",
  "build/",
  ".next/",
  "coverage/",
  "package-lock.json",
  "yarn.lock",
  "pnpm-lock.yaml"
];

function isFirstCommit() {
  try {
    run("git rev-parse --verify HEAD");
    return false;
  } catch {
    return true;
  }
}

function getCurrentBranch() {
  return run("git rev-parse --abbrev-ref HEAD");
}


async function generateCommitMessage(diff, filesChanged, fileCount, firstCommit) {
  try {
    const res = await axios.post(
      "https://backend-gitcommit.onrender.com/api/generate-commit-message",
      {
        diff,
        filesChanged,
        fileCount,
        firstCommit
      }
    );

    console.log("Generated Commit Message:", res.data.commitMessage);
    return res.data.commitMessage;
  } catch (err) {
    console.error("Error calling generateCommitMessage API:", err.response?.data || err.message);
    return "chore: update project files";
  }
}

function stageAll() {
  run("git add .");
}

function commitWithMessage(message) {
  const safeMessage = message.replace(/"/g, '\\"');
  run(`git commit -m "${safeMessage}"`);
}

async function prepareCommitMessage() {
  stageAll();

  const excludeArgs = IGNORE_PATHS.map(p => `:(exclude)${p}`).join(" ");
  let diff;

  if (isFirstCommit()) {
    diff = run(`git diff --cached --root --unified=0 -- . ${excludeArgs}`);
  } else {
    diff = run(`git diff --cached --unified=0 -- . ${excludeArgs}`);
  }

  if (!diff.trim()) return null;

  const filesChangedList = run("git diff --cached --name-only").split("\n");
  const fileCount = filesChangedList.length;

  return await generateCommitMessage(
    diff,
    filesChangedList.join(", "),
    fileCount,
    isFirstCommit()
  );
}

function autoPush(branch) {
  if (!branch) branch = getCurrentBranch();
  run(`git push origin ${branch}`);
}

module.exports = {
  prepareCommitMessage,
  commitWithMessage,
  autoPush
};

